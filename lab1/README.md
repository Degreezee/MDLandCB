# Лабораторная работа 1
## Вступление
Далее будет использоваться SASM, так как там достаточно удобный графический интерфейс, отладчик и т.д. Чтобы настроить его под наши нужды, зайдите в Настройки -> Настройки -> Построение -> Режим: х86, Ассемблер: NASM. Остальные поля SASM выставит автоматически.

![Настройки](https://raw.githubusercontent.com/Degreezee/i4md/refs/heads/dev/lab1/1.png)
## Шаблон для NASM x86
```nasm
    section .data
ExitMsg db "Press Enter to Exit",10
lenExit equ $-ExitMsg
    section .bss
InBuf   resb    10
lenIn   equ     $-InBuf
    section .text
    global  main
main:
    ; write
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, ExitMsg
    mov     edx, lenExit
    int     80h
    ; read
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, InBuf
    mov     edx, lenIn
    int     80h
    ; exit
    mov     eax, 1
    xor     ebx, ebx
    int     80h
```

## Пункт 1.2.8
После выполнения предыдущих пунктов методички и настройки SASM, переходим к самому интересному - написанию кода. В шаблон программы для 32-битного ассемблера добавим строки кода согласно методичке.
Получим:
```nasm
    section .data
ExitMsg db "Press Enter to Exit",10
lenExit equ $-ExitMsg
A       dd   -30
B       dd   21
    section .bss
InBuf   resb    10
lenIn   equ     $-InBuf
X       resd    1
    section .text
    global  main
main:
    mov     EAX,[A] ; загрузить число A в регистр EAX
    add     EAX,5   ; сложить EAX и 5, результат в EAX
    sub     EAX,[B] ; вычесть число B, результат в EAX
    mov     [X],EAX ; сохранить результат в памяти
    ; write
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, ExitMsg
    mov     edx, lenExit
    int     80h
    ; read
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, InBuf
    mov     edx, lenIn
    int     80h
    ; exit
    mov     eax, 1
    xor     ebx, ebx
    int     80h
```

Запускаем код и проверяем, что он выполняется. Отлично, этот пункт выполнен.

## Пункт 1.2.9
### Запуск отладчика
Приступаем к отладке. Для того, чтобы посмотреть, что хранится в регистрах и переменных, нужно запустить отладку (см. рисунок ниже, левая кнопка) и использовать сочетания клавиш ctrl+R и ctrl+M.

![Меню отладки](https://github.com/Degreezee/i4md/blob/dev/lab1/2.png)

Чтобы посмотреть значения переменных в памяти, нужно дважды нажать на "Добавить" и ввести название переменной. В столбце "Тип" нужно выбрать Hex, d.
### Просмотр значений
#### Запуск программы
![Меню отладки](https://github.com/Degreezee/i4md/blob/dev/lab1/3_begin.png)

Под каждую переменную зарезервировано 4 байта (т.к. DWORD).
В переменной А записано отрицательное число -30, следовательно, для его хранения используется дополнительный код. Проверим, что число -30 действительно записано в памяти корректно.
Число 30 в двоичной системе записывается как 11110. Добавим незначащие нули, чтобы число заняло 4 байта: 0000 0000 0000 0000 0000 0000 0001 1110. Инвертируем нули и единицы: 1111 1111 1111 1111 1111 1111 1110 0001. Добавим единицу к младшему разряду: 1111 1111 1111 1111 1111 1111 1110 0010. Переведем в шестнадцатиричную систему : ffffffe2. Число записано корректно, что мы и наблюдаем на изображении выше. В переменной B записано число 21, в двоичном виде: 10101 положительное, обратный код не нужен. Добавим незначащие нули, чтобы их число было кратно четырем: 00010101. Переведем в шестнадцатиричную систему: 15. Число записано корректно. В переменной Х пока ничего не записано.

#### mov eax,[A]
![Меню отладки](https://github.com/Degreezee/i4md/blob/dev/lab1/4_mov_eax_A.png)

Значение А перенесено в регистр eax корректно.
#### add eax,5
![Меню отладки](https://github.com/Degreezee/i4md/blob/dev/lab1/5_add_eax_5.png)

К -30 прибавили 5. В eax должно быть записано число -25. Проверим с помощью алгоритма, описанного ранее, но в обратном порядке: ffffffe7 -> 1111 1111 1111 1111 1111 1111 1110 0111 -> 1111 1111 1111 1111 1111 1111 1110 0110 -> 0000 0000 0000 0000 0000 0000 0001 1001 -> 11001 -> 25. Т.к. число было записано в обратном коде, следовательно, оно отрицательное (-25).

#### sub eax,[B]
![Меню отладки](https://github.com/Degreezee/i4md/blob/dev/lab1/6_sub_eax_b.png)

Из -25 вычитается 21. Должно получится -46. Проверим результат по тому же алгоритму: ffffffd2 -> 1111 1111 1111 1111 1111 1111 1101 0010 -> 1111 1111 1111 1111 1111 1111 1101 0001 -> 0000 0000 0000 0000 0000 0000 0010 1110 -> 101110 -> -46.

#### mov [X],eax
![Меню отладки](https://github.com/Degreezee/i4md/blob/dev/lab1/7_mov_X_eax.png)

Значение eax корректно присвоено переменной X.
