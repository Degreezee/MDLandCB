# Лабораторная работа 1
## Вступление
***ВАЖНО***
**Приведенные ниже материалы не являются готовым отчетом и требуют проверки и исправления**

Далее будет использоваться SASM, так как там достаточно удобный графический интерфейс, отладчик и т.д. Чтобы настроить его под наши нужды, зайдите в Настройки -> Настройки -> Построение -> Режим: х86, Ассемблер: NASM. Остальные поля SASM выставит автоматически.

![Настройки](https://raw.githubusercontent.com/Degreezee/i4md/refs/heads/dev/lab1/1.png)
## Шаблон для NASM x86
```nasm
    section .data
ExitMsg db "Press Enter to Exit",10
lenExit equ $-ExitMsg
    section .bss
InBuf   resb    10
lenIn   equ     $-InBuf
    section .text
    global  main
main:
    ; write
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, ExitMsg
    mov     edx, lenExit
    int     80h
    ; read
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, InBuf
    mov     edx, lenIn
    int     80h
    ; exit
    mov     eax, 1
    xor     ebx, ebx
    int     80h
```

## Пункт 1.2.8
После выполнения предыдущих пунктов методички и настройки SASM, переходим к самому интересному - написанию кода. В шаблон программы для 32-битного ассемблера добавим строки кода согласно методичке.
Получим:
```nasm
    section .data
ExitMsg db "Press Enter to Exit",10
lenExit equ $-ExitMsg
A       dd   -30
B       dd   21
    section .bss
InBuf   resb    10
lenIn   equ     $-InBuf
X       resd    1
    section .text
    global  main
main:
    mov     EAX,[A] ; загрузить число A в регистр EAX
    add     EAX,5   ; сложить EAX и 5, результат в EAX
    sub     EAX,[B] ; вычесть число B, результат в EAX
    mov     [X],EAX ; сохранить результат в памяти
    ; write
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, ExitMsg
    mov     edx, lenExit
    int     80h
    ; read
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, InBuf
    mov     edx, lenIn
    int     80h
    ; exit
    mov     eax, 1
    xor     ebx, ebx
    int     80h
```

Запускаем код и проверяем, что он выполняется. Отлично, этот пункт выполнен.

## Пункт 1.2.9
### Запуск отладчика
Приступаем к отладке. Для того, чтобы посмотреть, что хранится в регистрах и переменных, нужно запустить отладку (см. рисунок ниже, левая кнопка) и использовать сочетания клавиш ctrl+R и ctrl+M.

![Меню отладки](https://github.com/Degreezee/i4md/blob/master/lab1/2.png)

Чтобы посмотреть значения переменных в памяти, нужно дважды нажать на "Добавить" и ввести название переменной. В столбце "Тип" нужно выбрать Hex, d.
### Просмотр значений
#### Запуск программы
![Меню отладки](https://github.com/Degreezee/i4md/blob/master/lab1/3_begin.png)

Под каждую переменную зарезервировано 4 байта (т.к. DWORD).
В переменной А записано отрицательное число -30, следовательно, для его хранения используется дополнительный код. Проверим, что число -30 действительно записано в памяти корректно.
Число 30 в двоичной системе записывается как 11110. Добавим незначащие нули, чтобы число заняло 4 байта: 0000 0000 0000 0000 0000 0000 0001 1110. Инвертируем нули и единицы: 1111 1111 1111 1111 1111 1111 1110 0001. Добавим единицу к младшему разряду: 1111 1111 1111 1111 1111 1111 1110 0010. Переведем в шестнадцатиричную систему : ffffffe2. Число записано корректно, что мы и наблюдаем на изображении выше. В переменной B записано число 21, в двоичном виде: 10101 положительное, обратный код не нужен. Добавим незначащие нули, чтобы их число было кратно четырем: 00010101. Переведем в шестнадцатиричную систему: 15. Число записано корректно. В переменной Х пока ничего не записано.

#### mov eax,[A]
![Меню отладки](https://github.com/Degreezee/i4md/blob/master/lab1/4_mov_eax_A.png)

Значение А перенесено в регистр eax корректно.
#### add eax,5
![Меню отладки](https://github.com/Degreezee/i4md/blob/master/lab1/5_add_eax_5.png)

К -30 прибавили 5. В eax должно быть записано число -25. Проверим с помощью алгоритма, описанного ранее, но в обратном порядке: ffffffe7 -> 1111 1111 1111 1111 1111 1111 1110 0111 -> 1111 1111 1111 1111 1111 1111 1110 0110 -> 0000 0000 0000 0000 0000 0000 0001 1001 -> 11001 -> 25. Т.к. число было записано в обратном коде, следовательно, оно отрицательное (-25).

#### sub eax,[B]
![Меню отладки](https://github.com/Degreezee/i4md/blob/master/lab1/6_sub_eax_b.png)

Из -25 вычитается 21. Должно получится -46. Проверим результат по тому же алгоритму: ffffffd2 -> 1111 1111 1111 1111 1111 1111 1101 0010 -> 1111 1111 1111 1111 1111 1111 1101 0001 -> 0000 0000 0000 0000 0000 0000 0010 1110 -> 101110 -> -46.

#### mov [X],eax
![Меню отладки](https://github.com/Degreezee/i4md/blob/master/lab1/7_mov_X_eax.png)

Значение eax корректно присвоено переменной X.

## Пункт 1.2.10
Запишем нужные данные в .data и .bss:
```nasm
    section .data
    val1    db 255
    chart   dw 256
    lue3    dw -128
    v5      db 10h
            db 100101b
    beta    db 23,23h,0ch
    sdk     db "Hello",10
    min     dw -32767
    ar      dd 12345678h
    valar   times   5   db  8
    ExitMsg db "Press Enter to Exit",10
    lenExit equ $-ExitMsg
    section .bss
    alu     resw 10
    f1      resb 5
    InBuf   resb    10
    lenIn   equ     $-InBuf
    section .text
    global  main
main:
    mov ebp, esp; for correct debugging
    ; write
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, ExitMsg
    mov     edx, lenExit
    int     80h
    ; read
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, InBuf
    mov     edx, lenIn
    int     80h
    ; exit
    mov     eax, 1
    xor     ebx, ebx
    int     80h
```
![Данные в памяти](https://github.com/Degreezee/i4md/blob/master/lab1/8_only_mem.png)

## Пункт 1.2.11
Для определения числа размером два байта используем dw (define word), для числа размером 4 байта - dd (define double word), для символьной строки - db (define byte):
```nasm
    section .data
    A       dw  25             ; Число 25 размером 2 байта
    B       dd  -35            ; Число -35  размером 4 байта
    C       db  "IvanИван", 0  ; Символьная строка, содержащая имя латинскими и русскими буквами
    ExitMsg db "Press Enter to Exit",10
    lenExit equ $-ExitMsg
    section .bss
    InBuf   resb    10
    lenIn   equ     $-InBuf
    section .text
    global  main
main:
    mov ebp, esp; for correct debugging
    ; write
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, ExitMsg
    mov     edx, lenExit
    int     80h
    ; read
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, InBuf
    mov     edx, lenIn
    int     80h
    ; exit
    mov     eax, 1
    xor     ebx, ebx
    int     80h
```

Запустим отладчик и посмотрим, как данные хранятся в памяти:
![Данные в памяти](https://github.com/Degreezee/i4md/blob/master/lab1/9.png)
## Пункт 1.2.12
Данные представлены в шестнадцатиричной системе. Переведем 25 00 и 00 25 в десятичную систему. 25 00 -> 9472, 00 25 -> 37. Определим эти числа и проверим их в отладчике.
```nasm
    section .data
    A       dw  9472
    B       dw  37
    ExitMsg db "Press Enter to Exit",10
    lenExit equ $-ExitMsg
    section .bss
    InBuf   resb    10
    lenIn   equ     $-InBuf
    section .text
    global  main
main:
    mov ebp, esp; for correct debugging
    ; write
    mov     eax, 4
    mov     ebx, 1
    mov     ecx, ExitMsg
    mov     edx, lenExit
    int     80h
    ; read
    mov     eax, 3
    mov     ebx, 0
    mov     ecx, InBuf
    mov     edx, lenIn
    int     80h
    ; exit
    mov     eax, 1
    xor     ebx, ebx
    int     80h
```
![Данные в памяти](https://github.com/Degreezee/i4md/blob/master/lab1/10.png)

Как можно заметить, два младших байта имеют значения 25 00 и 00 25, что и требовалось.

## Пункт 1.2.13
Добавим переменнные F1 и F2 со значениями 65535, добавим к ним 1. Проверим значения и флаги в отладчике.
В начале:
![Начало](https://github.com/Degreezee/i4md/blob/master/lab1/11_begin.png)

После сложения F1 и 1:
![Сложение F1](https://github.com/Degreezee/i4md/blob/master/lab1/12_after_F1.png)

После сложения F2 и 1:
![Сложение F2](https://github.com/Degreezee/i4md/blob/master/lab1/13_after_F2.png)
Как видно из отладчика, после сложения значений F1 и 1, происходит переполнение (флаг CF - беззнаковое переполненние). При сложении значений F2 и 1, такого не происходит, т.к. результат занимает меньше 4 зарезервированных байтов.

## Контрольные вопросы
### Контрольный вопрос 1
**Дайте определение ассемблеру. К какой группе языков он относится?**
Ассемблер - транслятор программы, написанной на языке ассемблера в машинный код. Это язык низкого уровня, обозначающий команды, выполняемые процессором компьютера.

### Контрольный вопрос 2
**Из каких частей состоит заготовка программы на ассемблере?**
Заготовка программы состоит из трех секций (сегментов):
.text – сегмент кода;
.data – сегмент инициализированных данных;
.bss – сегмент неинициализированных данных.

### Контрольный вопрос 3
**Как запустить программу на ассемблере на выполнение? Что происходит с программой на каждом этапе обработки?**
После написания исходного кода происходит несколько этапов обработки:
1. Ассемблирование. На этом этапе команды на языке ассемблера переводятся в машинный код. Это можно сделать с помощью команды `nasm -f elf32 -o program.o program.asm`. После выполнения получается файл program.o, содержащий машинный код.
2. Компоновка. На этом этапе компоновщик собирает один или несколько файлов или библиотек в один исполняемый файл. На примере компоновщика gcc, компоновка производится командой `gcc -o program program.o`.
3. Запуск программы. На этом этапе система загружает исполняемый файл в память, и процессор начинает выполнение команд.

### Контрольный вопрос 4
**Назовите основные режимы работы отладчика. Как осуществить пошаговое выполнение программы и просмотреть результаты выполнения машинных команд.**
1. Запуск программы:
    - Run (Запуск): Запускает программу с начала до конца или до достижения точки останова.
    - Continue (Продолжить): Продолжает выполнение программы после остановки на точке останова или после пошагового выполнения.

2. Пошаговое выполнение:
    - Step Into (Шаг с заходом): Выполняет строку кода и переходит внутрь функции, если выполнен вызов функции.
    - Step Over (Шаг с обходом): Выполняет строку кода, но не переходит внутрь функции, если выполнен вызов функции.
    - Step Out (Шаг с выходом): Выполняет оставшуюся часть текущей функции и возвращается к коду, откуда была вызвана функция.

3. Установка точек останова (Breakpoints):
    - Установка точек останова позволяет приостановить выполнение программы в определенных местах кода.

4. Просмотр и изменение данных:
    - Watch (Просмотр): Позволяет отслеживать значения переменных и выражений.
    - Inspect (Инспектирование): Позволяет просматривать и изменять значения переменных и регистров.

### Контрольный вопрос 5
**В каком виде отладчик показывает положительные и отрицательные целые числа? Как будут представлены в памяти числа:** ***A dw 5,-5 ?*** **Как те же числа будут выглядеть после загрузки в регистр AX?**
Под оба числа зарезервировано 2 байта, следовательно, 5 будет выглядеть как 0000 0000 0000 0101 в двоичной системе и 0x0005 в шестнадцатиричной. Для хранения отрицательных чисел используется дополнительный код, а значит, -5 в двоичной системе будет выглядеть как 1111 1111 1111 1011 в двоичной системе и 0xFFFB в шестнадцатиричной. Когда числа загружаются в регистр AX, они будут представлены так же, как и в памяти.

### Контрольный вопрос 6
**Каким образом в ассемблере программируются выражения? Составьте фрагмент программы для вычисления С=A+B, где A, В и С – целые числа формата BYTE.**
Математические выражение в ассемблере программируются следующим образом:
1. **add** - команда, отвечающая за сложение чисел. Работает с двумя операндами. Результат записывается по адресу первого операнда. Существует два вида этой команды: ADD и ADC. В отличие от ADD, команда ADС добавляет к результату значение бита флага переноса CF. Допустимые варианты:
    - add reg,reg
    - add mem,reg
    - add reg,mem
    - add mem,imm
    - add reg,imm

2. **sub** - команда, отвечающая за вычитание чисел. Работает с двумя операндами. Результат записывается по адресу первого операнда. Существует два вида этой команды: SUB и SBB. В отличие от SUB команда SBB вычитает из результата значение бита флага переноса CF. Допустимые варианты те же, что и у сложения:
    - sub reg,reg
    - sub mem,reg
    - sub reg,mem
    - sub mem,imm
    - sub reg,imm
3. **inc** и **dec** - команды добавления/вычитания единицы. Допустимые варианты:
    - INC reg/mem
    - DEC reg/mem
4. **mul** и **imul** - команды умножения. При вызове команды необходимо указать адрес второго операнда. Первый операнд должен находиться по адресу AL/AX/EAX. Допустимые варианты:
    mul/imul r|m8  (AX= AL*<Операнд2>)
    mul/imul r|m16 (DX:AX= AX*<Операнд2>)
    mul/imul r|m32 (EDX:EAX= EAX*<Операнд2>)
5. **Команды «развертывания» чисел**
    - CBW  - байт в слово AL -> AX
    - CWD  - слово в двойное слово AX -> DX:AX
    - CDQ  - двойное слово в учетверенное EAX -> EDX:EAX
    - CWDE - слово в двойное слово AX -> EAX
6. **div** и **idiv** - команды деления. Аналогично с умножением - первый операнд по адресу AL/AX/EAX, второй указывается при вызове функции. Допустимые варианты (и запись остатка от деления):
    - div/idiv r|m8   (AL  = AX:        <Операнд2>, AH - остаток)
    - div/idiv r|m16  (AX  = (DX:AX):   <Операнд2>, DX - остаток)
    - div/idiv r|m32  (EAX = (EDX:EAX): <Операнд2>, EDX - остаток)

**С = A + B**
```nasm
    section .data
    A   db  ...
    B   db  ...
    ...
    section .bss
    B   resb 1
    ...
    section .text
    mov     eax,[A]
    add     eax,[B]
    mov     [C],eax
```
